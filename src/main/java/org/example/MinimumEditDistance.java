package org.example;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertEquals;


public class MinimumEditDistance {


    @Test
    public void testMinimumEditDistance() {
        assertEquals(0, MinimumEditDistance.distance("kitten", "kitten"));
        assertEquals(6, MinimumEditDistance.distance("kitten", ""));
        assertEquals(6, MinimumEditDistance.distance("", "kitten"));
        assertEquals(5, MinimumEditDistance.distance("editing", "distance"));
        assertEquals(4, MinimumEditDistance.distance("kitten", "sittingg")); // it's actually 4!
    }

    @Test
    public void testMinimumEditDistanceGPT() {
        // Test with identical strings
        assertEquals(0, MinimumEditDistance.distance("abc", "abc"));

        // Test with one empty string
        assertEquals(3, MinimumEditDistance.distance("", "xyz"));
        // assertEquals(4, MinimumEditDistance.distance("abc", ""));

        // Test with strings of different lengths
        assertEquals(3, MinimumEditDistance.distance("kitten", "sitting"));
        assertEquals(5, MinimumEditDistance.distance("intention", "execution"));

        // Test with strings that require only substitution
       // assertEquals(2, MinimumEditDistance.distance("abcdef", "abqdef"));

        // Test with strings that require only insertion and deletion
       // assertEquals(3, MinimumEditDistance.distance("abcdef", "abcf"));

        // Test with strings that require a combination of operations
        assertEquals(6, MinimumEditDistance.distance("kitten", "sittinen"));
    }
    @Test
    public void testDistance() {
        // Given


        // Test cases
        assertEquals(3, MinimumEditDistance.distance("kitten", "sitting"));
        assertEquals(0, MinimumEditDistance.distance("apple", "apple"));
        assertEquals(5, MinimumEditDistance.distance("apple", ""));
        assertEquals(5, MinimumEditDistance.distance("", "apple"));
        assertEquals(1, MinimumEditDistance.distance("apple", "aple"));
        assertEquals(3, MinimumEditDistance.distance("flaw", "lawn"));
        assertEquals(2, MinimumEditDistance.distance("intention", "execution"));
    }


        public static int distance(String str1, String str2) {
            int m = str1.length();
            int n = str2.length();

            // Create a 2D array to store the minimum edit distances
            int[][] dp = new int[m + 1][n + 1];

            // Initialize the first row and first column
            for (int i = 0; i <= m; i++) {
                dp[i][0] = i;
            }

            for (int j = 0; j <= n; j++) {
                dp[0][j] = j;
            }

            // Calculate the minimum edit distance using dynamic programming
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]);
                    }
                }
            }

            // The value in the bottom-right corner of the dp matrix is the minimum edit distance
            return dp[m][n];
        }




    public static int distance2(String str1, String str2) {

        //  Given two strings, finds the minimum edit distance between them.
        // Allowed operations include deletion, insertion, and substitution.
        // The function distance will take the arguments 'str1', a string and 'str2', a string.
        // It will return an int.
        // The output should be the minimum edit distance between the two strings.
        // The output should be printed to the standard output.
        // The output should be rounded to the nearest integer.

        // The minimum edit distance between two strings is the minimum number of operations needed to transform one string into the other.
        // The allowed operations are deletion, insertion, and substitution.
        // For example, the minimum edit distance between "kitten" and "sitting" is 3.
        // The minimum edit distance between "kitten" and "kitten" is 0.
        // The minimum edit distance between "kitten" and "" is 6.
        // The minimum edit distance between "" and "kitten" is 6.
        // The minimum edit distance between "kitten" and "sittin" is 2.
        // The minimum edit distance between "kitten" and "sittingg" is 3. // generated by Copilot (and wrong!)

        // The minimum edit distance between two strings can be computed recursively.
        // The base case is when one of the strings is empty.
        // In this case, the minimum edit distance is the length of the other string.
        // The recursive case is when both strings are non-empty.
        // In this case, the minimum edit distance is the minimum of the following:
        // 1. The minimum edit distance between the first n-1 characters of str1 and the first n characters of str2, plus 1.
        // 2. The minimum edit distance between the first n characters of str1 and the first n-1 characters of str2, plus 1.
        // 3. The minimum edit distance between the first n-1 characters of str1 and the first n-1 characters of str2, plus 1 if the last characters are different, and 0 otherwise.

        // The following code is a recursive implementation of the minimum edit distance.
        // It is not efficient, because it computes the same subproblems multiple times.
        // Your goal is to implement a dynamic programming solution to the minimum edit distance problem.
        // The dynamic programming solution should be more efficient than the recursive solution.

        // The following code is a recursive implementation of the minimum edit distance.
        if (str1.length() == 0) {
            return str2.length();
        }

        if (str2.length() == 0) {
            return str1.length();
        }

        int cost = 0;
        if (str1.charAt(str1.length() - 1) != str2.charAt(str2.length() - 1)) {
            cost = 1;
        }

        int dist1 = distance(str1.substring(0, str1.length() - 1), str2) + 1;
        int dist2 = distance(str1, str2.substring(0, str2.length() - 1)) + 1;
        int dist3 = distance(str1.substring(0, str1.length() - 1), str2.substring(0, str2.length() - 1)) + cost;

        return Math.min(dist1, Math.min(dist2, dist3));







    }



}
